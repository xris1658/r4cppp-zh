# 图和内存池分配

（提示：可以通过下载此目录并运行 `cargo run` 的方式运行本章示例。）

由于 Rust 严格的生存期和可变性要求，在 Rust 中构建图有些尴尬。对象图在面向对象编程中很常见。本教程中，我会介绍几种不同的实现方式。我推荐的方式使用了内存池分配（arena allocation）），并使用了显式生存期的高级内容。我会介绍讨论数种让使用这种方法更简单的 Rust 特性，用于完成本章。

[图](http://en.wikipedia.org/wiki/Graph_%28abstract_data_type%29) 是若干个点（node）和连接点的边（edge）的集合。图是链表和树结构更一般的形式。每个点都有若干个子项和若干个父项（通常不会讨论父项和子项，而是讨论指入和指出点的边）。图可使用邻接列表或邻接矩阵表示。前者基本上就是为图中每个点构建个点对象，且每个点对象都持有邻接点的列表。邻接矩阵则是一个布尔类型的矩阵，指示有无从行对应点指向列对应点的边。我们只讲用邻接列表表示的方式，因为邻接矩阵会牵扯到和 Rust 不太相关的不同问题。

基本来说，存在两个正交（orthogonal）的问题：如何管理图的生存期，以及如何管理可变性。

第一个问题基本上可归结为“使用什么指针指向图中其他点”这一问题。因为类似图的数据结构是递归的（类型递归，但数据不递归），我们只能使用指针，无法建立完全基于值的结构。由于图可以出现闭环，但 Rust 中对象的所有权不能出现闭环，因此 `Box<Node>` 不能用作指针类型（或许会为树结构和链表使用这种类型）。

至于第二个问题，没有哪个图真的是不可变的。因为图可能存在闭环，图不能在一条语句中全部创建完成。因此退一步讲，图必须在初始化时可变。Rust 中常用的不变因素是，所有指针要么独占，要么不可修改。图中的边必须可变（至少初始化时可变），此外，可存在多个边指向一个点，因此边无法保证独占。因此要管理可变性要进行一些高级操作。

一种解法是使用可变原始指针（`*mut Node`）。这是最灵活的方式，同时也最危险。要用的话，必须手动管理生存期，类型系统无法插手。这样可以造出非常灵活且高效的数据结构，但你必须万分小心。这种方式需要一下兼顾生存期和可变性两个问题。但这么管理是通过根本上忽略 Rust 所有的长处进行的：编译器帮不了忙（写起来也不舒服，因为原始指针无法自动引用或解引用）。由于使用原始指针构图和 C++ 中构图没多少区别，我这里是不会讲的。

实现生存期管理可以使用引用计数（使用 `Rc<...>`，共享所有权），或者内存池分配（所有点的生存期相同，均由一个内存池对象管理，也可以使用借用引用 `&...`）。前者更灵活（可以从图外部获取任意生存期的点的引用），除此之外后面都是更好的选择。

要管理可变性，可以使用 `RefCell`，即利用 Rust 的设施实现获取动态的内部可变性，也可以手动管理可变性（这样只得使用 `UnsafeCell` 与编译器沟通内部可变性）。前者更安全，后者更高效。两种方式编码都不怎么舒服。

注意，如果图可能会有闭环，且使用 `Rc`，则需要采取额外措施打破循环，防止内存泄漏。由于 Rust 的 `Rc` 指针没有环状集合（cycle collection），如果图中出现闭环，则引用计数永远无法归零，导致图无法销毁。要解决这一问题，可以使用 `Weak` 指针，或者得知要销毁图的时候手动打破循环。前一种方式更可靠。如果两种方法都不用，那么例子会出现内存泄漏。使用借用引用和内存池分配的方式就不会有这种问题，因而更高级。

我用个很简单的例子比较下这几种不同方式。我们直接用 `Node` 表示图中的点，其持有字符串数据（代表某种较为复杂的数据结构），以及邻接点（`边`）的 `Vec`。使用 `init` 函数创建简单的图，使用 `traverse` 函数对图进行先序的深度优先遍历。我们会用其打印图中每个点的数据。最终，使用 `Node::first` 方法返回 `self` 点的第一个邻接点的引用，使用 `foo` 函数打印一个点的数据。这些函数替代了涉及操纵图中点的较复杂的操作。

为力求信息量尽可能丰富，且防止读者无聊，我会讲两个选择——引用计数和 `RefCell`，以及内存池分配和 `UnsafeCell`——的两中组合。另外两种组合留作练习。

## `Rc<RefCell<Node>>`

参见[完整示例](src/rc_graph.rs)。

此选择更加安全，因为没有不安全代码。同时它效率也最低，使用方式最蹩脚。不过灵活性不错，因为使用引用计数，因此图中的点可以轻易在图外重用。如果你需要完全可变的图，或是需要点独立于图存在，我会推荐这种方式。

点的结构形如

```rs
struct Node {
    datum: &'static str,
    edges: Vec<Rc<RefCell<Node>>>,
}
```

新建点还行：`Rc::new(RefCell::new(Node { ... }))`。要在初始化时加边，则需将初始点可变借出，并将指向的点复制到边的 `Vec` 中（此操作复制指针，自增引用计数，但不会复制点）。例如：

```rs
let mut mut_root = root.borrow_mut();
mut_root.edges.push(b.clone());
```

`RefCell` 动态确保在写点时没有进行其他读写操作。

每次访问点都需要使用 `.borrow()` 将 `RefCell` 借出。`first` 方法需返回引用计数指针，不能返回借用引用，因此 `first` 的调用方同样需要借用：

```rs
fn first(&self) -> Rc<RefCell<Node>> {
    self.edges[0].clone();
}

pub fn main() {
    let g = ...;
    let f = g.first();
    foo(&*f.borrow());
}
```

## 结合 `&Node` 和 `UnsafeCall`

参见[完整实例](src/ref_graph.rs)。

用这种方法时，我们会将借用引用作为边使用。这种方式好，使用体验也好，可让我们将点主要操纵借用引用的“常规”Rust 库配合使用（注意，Rust 中引用计数对象有一点好：它们与生存期系统配合得不错。可以创建 `Rc` 的借用引用，以直接（安全）地引用数据。之前地例子中，`RefCell` 使我们无法做到这一点，但结合 `Rc` 和 `UnsafeCell` 应该就可以了）。

析构操作也能正确处理：唯一限制在于，所有点都必须同时销毁。点的析构和分配使用内存池处理。

另一方面，我们确实需要使用不少显式生存期的内容。可惜的是，这里我们无法受益于生存期消除。本节最后，我会探讨一些语言中能使现状更好的发展方向。

构造时，我们要修改可能引用数次的点。安全的 Rust 代码中做不到这一点，因此必须在 `unsafe` 代码块中初始化。由于点可变，且被多次引用，必须使用 `UnsafeCell` 告知 Rust 编译器，不能依赖常用的不变因素。

何时应该使用这种方式？图必须只在初始化时修改。此外，我们需要图中所有点的生存期一致（只要点能够同时销毁，我们也可以放宽这一限制，以允许初始化之后加点）。类似的是，针对点可修改的时机，我们可以依赖更复杂的规则，但保证事情简单需要付出代价，因为这时程序员负责保证安全。

内存池分配是这样一种内存管理技术，其中一系列对象的生存期相同，可以同时回收对应内存。内存池（arena） 是一种负责分配和解分配内存的对象。由于大块内存一次性分配以及解分配（而非为对象逐个分配内存），因此内存池分配非常高效。通常，所有对象都在一块连续的内存上分配，提升了遍历图时的缓存连贯性（cache coherency）。

在 Rust 中，内存池构造由 [libarena](https://doc.rust-lang.org/1.1.0/arena/index.html) 程序包（crate）提供支持，而且编译器中随处都会使用。内存池有两种：有类型内存池和无类型内存池。后者更加灵活，可以分配各种对象。内存池构造的对象，生存期都一样，均为内存池的参数。类型系统会确保内存池中对象的引用不会比内存池本身活得久。

要使用内存池，必须在点结构中包含图的生存期 `'a`。我们将邻接点的 `Vec` 数组封装到 `UnsafeCell` 中，表示我们会在其不可变时修改它：

```rs
struct Node<'a> {
    datum: &'static str,
    edges: UnsafeCell<Vec<&'a Node<'a>>>,
}
```

新函数同样必须使用这一生存期，必须使用进行分配的内存池的参数：

```rs
fn new<'a>(datum: &'static str, arena: &'a TypedArena<Node<'a>>) -> &'a Node<'a> {
    arena.alloc(Node {
        datum: datum,
        edges: UnsafeCell::new(Vec::new()),
    })
}
```

我们使用内存池解分配点。图的生存期派生自内存池引用的生存期，因此必须从涵盖图的生存期中传入内存池。（可以想象一个类型系统的扩展，其允许在自身作用域外创建值，但是还没有添加这种东西的计划）。当内存池离开作用域时，整个图被销毁（Rust 的类型系统确保无法持有图的引用）。

加边有点不一样：

```rs
(*root.edges.get()).push(b);
```

这种方式基本上和 `root.edges.push(b)` 类似，都是将点 `b` 加入边的表中。然而，由于 `edges` 被封装到 `UnsafeCell` 中，我们得对其调用 `get()`。此操作返回一个指向边的可变原始指针（`*mut Vec<&Node>`），我们得以修改 `edges`。然而，它还要求我们手动对指针解引用（因为原始指针不会自动解引用），因此需要使用 `(*...)`。最后，解引用原始指针不安全，因此这段代码需要包含在不安全代码块中。

`travese` 的有趣之处在于：

```rs
for n in &(*self.edges.get()) {
    n.traverse(f, seen);
}
```

就获取边表而言，我们遵循了之前的样式，需要使用不安全代码块。这里，我们知道，这一操作实际是安全的，因为我们一定是在初始化后执行这一操作，因此不会发生修改。

`first` 方法获取 `edges` 表的方式也一样，也必须放入不安全代码块中。然而，和使用 `Rc<RefCell<_>>` 相对的是，我们可以返回点的借用引用。这一点很方便。我们可以推断出，这个不安全代码块实际是安全的，因为不作修改，而且在初始化之后发生。

```rs
fn first(&'a self) -> &'a Node<'a> {
    unsafe {
        (*self.edges.get())[0]
    }
}
```

### 针对此方法的未来语言改进

我确信，内存池分配和使用借用引用是 Rust 中一种重要的模式。我们应针对语言多做工作，使这种模式更安全，更易用。我希望使用内存池能随着正在进行的[分配器](https://github.com/rust-lang/rfcs/pull/244)相关工作变得更好用。我注意到了另外三种改进：

#### 安全初始化

面向对象的世界中已经有了很多为保证只在初始化时可变的研究。这一点如何在 Rust 中进行，这是个研究开放的问题，不过看起来我们需要表示一个可变，非独占但限制作用域的指针。离开了作用域，任何现有指针都会变回一般的借用引用，要么不可变，要么独占。

这种方式的优势在于，我们得以表达初始化时可变，初始化后不可变的模式。它还依赖于一个不变因素：尽管单个对象共享，但对象的聚合（本例中的图）是独占的。我们就可以采用引用和 `UnsafeCell` 的方式，而无需使用 `UnsafeCell` 本身以及不安全代码块，使得这一方式更易用，更安全。

ETH Zurich 的 Alex Summers 和 Julian Viereck 在进一步研究这一特性。

#### 泛型模块

对于一个图而言，图的生存期是恒定的。重复标注生存期只是样板而已。要使其更易用，一种方式是允许生存期对图模块做参数化处理，使我们不用为每个结构、实现和函数都写一遍生存期。图的生存期仍需要在模块外指定，不过但愿推导机制能处理大多数使用操作（和函数调用类似）。

要了解代码，参阅 [ref_graph_generic_mod.rs](src/ref_graph_generic_mod.rs)。（我们还应该能使用安全初始化（上面提出的内容）移除不安全的代码。）

另见这一 [RFC Issue](https://github.com/rust-lang/rfcs/issues/424)。

这一特性会大幅降低引用和 `UnsafeCell` 配合使用的语法开销。

#### 生存期消除

目前，我们允许程序员省略函数签名的一部分生存期，使其更加易用。`&Node` 方式用于图有些丑陋，其中一点在于它完全无法受益于生存期消除的规则。

Rust 中，数据结构带一般生存期是种常见的模式。引用这种数据结构会给出类似 `&'a Foo<'a>` 的类型，例如图的示例中的 `&'a Node<'a>`。这种情况下，有生存期消除的规则会很不错（译者注：省略 `&'a Foo<'a>` 中的一个 `'a`）。不过我不是很确定怎么用。

回看一下使用泛型模块的例子，我们似乎不需要大幅扩展生存期消除的规则（我并不确定 `Node::new` 能否脱离给定的生存期使用，不过就算不能，让它能用应该也是个相当简单的扩展）。我们可能想加些新规则，使得