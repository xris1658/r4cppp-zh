## 引用计数和原始指针

待补充：添加定制指针和 `Deref` 特征的讨论（此处不表，后文再讲）

到目前，我们已经讲了独占和借用指针。独占指针和 C++ 中的 `std::unique_ptr` 很相似，借用引用则是 C++ 中用指针和引用时常使用的“默认”指针（译者注：原始指针）。Rust 的语言或库中带有几个更罕见的指针。这些指针和 C++ 中习惯使用的多种智能指针大体相似。

这篇文章花了不少时间完成，但我还是不满意。内容不严谨的地方很多，不只是我行文如此，Rust 自身也是如此。希望后文中，随着语言发展，读者可以理解更透彻。在学习 Rust 时，你可能想现在跳过这一段，希望你用不着。这篇文章只是为了保证后文介绍其他指针类型时内容的完整性。

你或许会觉得 Rust 有很多指针类型，但一旦思考库中带有的多种指针类型，就会发现和 C++ 挺类似的。然而 Rust 中，你更容易在初学这门语言时遇到这些东西。因为 Rust 指针有着编译器支持，因此使用时更难犯错。

我不打算像独占和借用指针那样深入介绍，因为坦白地说，本文的指针没那么重要。之后可能会详述。

## Rc&lt;T&gt;

引用计数指针作为 Rust 标准库的一部分出现。此设施在 `std::rc` 模块中（马上讲模块。模块是例子中 `use` 语句的原因）。指向 `T` 类型对象的引用计数指针类型为 `Rc<T>`。使用静态方法创建引用计数指针（现在你可以认为和 C++ 的类似，但是后面就会知道二者有点不同）——`Rc::new(...)` 接收值，用于创建指向值的指针。这一构造方法遵循了 Rust 常用的移动 / 复制语义（和之前独占指针中讨论的类似）：无论复制还是移动，调用了 `Rc::new` 之后，便可以通过指针访问值。

对于其他指针类型，`.` 运算符会按需进行所有的解引用。可以使用 `*` 手动解引用。

要传递引用计数指针，需要使用 `clone` 方法。这事有点烂，但愿我们能改好，可惜，这事可不好说。可以创建指向值的（借用）引用，因此用不着一直复制。Rust 的类型系统保证引用计数的变量不会在所有引用过期之前销毁。创建引用的另一优点在于不用增减引用计数，因此性能更好（话虽如此，由于引用计数对象限于单个线程中，引用计数不必是原子操作，因此这点差别可能不大）。和 C++ 一样，可以创建指涉引用计数指针的引用。

引用计数的例子：

```rs
use std::rc::Rc;

fn bar(x: Rc<i32>) { }
fn bax(x: &i32) { }

fn foo() {
    let x = Rc::new(45);
    bar(x.clone()); // 引用计数 +1
    bax(&*x); // 引用计数不变
    println!("{}", 100 - *x);
} // 离开作用域时，所有引用计数指针都被销毁，引用计数归零，内存被回收
```

引用计数指针永远不可变。想要可变引用计数对象的话，需要使用 `Rc` 中封装的 `RefCell`（或 `Cell`）。

## `Cell` 和 `RefCell`

`Cell` 和 `RefCell` 是两种结构体，允许“违背”可变性的规定。如果不先讲 Rust 数据结构及其与可变性的交互，那么这里的工作机制就不太好解释，因此对象详情会在之后再讲。目前，你只需要知道，如果想要可变的引用计数对象，就需要封装在 `Rc` 中的 `Cell` 或 `RefCell`。你可能想为原始数据使用 `Cell`，为带有移动语义的数据使用 `RefCell`。因此，需要使用引用计数且可变的 `int`，可以使用 `Rc<Cell<int>>`。

## \*T：原始指针

最后，Rust 带有两种原始指针（又称作不安全指针）：表示不可变原始指针的 `*const T`，以及表示可变原始指针的 `*mut T`。分别使用 `&` 和 `&mut` 构建这两种指针（要获取 `*T` 而非 `&T` 的话，或许需要指定类型，因为 `&` 运算符既可创建借用引用，也可创建原始指针）。原始指针和 C 的指针类似，就是一个指向内存的指针，用途不受限制（不作转换的话无法进行指针算术，非用不可的话也可以用）。原始指针是 Rust 中唯一一种可以为空的指针类型。原始指针不会自动解引用（要调用方法，必须写成 `(*x).foo()`），也不会自动加引用。最重要的限制在于，这种指针不能在不安全代码块外解引用（因而无法使用）。在普通的 Rust 代码中，这种指针只能用来传递。

那么不安全代码是什么呢？Rust 带有强安全性保证，（很少）会阻止用户做需要做的事。因为 Rust 意欲成为系统编程语言，因此必须什么都能做，有时，这指的是做一些编译器无法判定为安全的事情。为完成这一点，Rust 引入了由关键字 `unsafe` 标记的不安全代码块。在不安全代码中，可以做不安全的事情：解引用原始指针、进行数组下表运算而不做边界检查、通过 FFI 调用另一门语言编写的代码、以及转换变量。显而易见的是，比起一般的 Rust 代码，编写不安全代码一定要多加小心。其实，应该少写不安全代码。不安全代码多用于程序库中的小片段，而不是客户代码。为保证安全，在不安全代码中，应该像通常写 C++ 代码一样添加安全措施。此外，必须自行确保代码维持了编译器通常保证的不变因素（invariant）。不安全代码块允许用户自行保证 Rust 的不变因素，不允许破坏这些因素。否则会为安全和不安全代码引入漏洞。

使用原始指针的例子：

```rs
fn foo() {
    let mut x = 5;
    let x_p: *mut i32 = &mut x;
    println!("x+5={}", add_5(x_p));
}

fn add_5(p: *mut i32) -> i32 {
    unsafe {
        if !p.is_null() {
            *p + 5 // 注意，原始指针不会自动解引用，
                   // 因此这一方法在 *i32 中实现，而非 i32
        } else {
            -1     // 不推荐这种错误处理的方式
        }
    }
}
```

到这里，Rust 的指针就全部讲完了。接下来先不管指针，去看 Rust 的数据结构。之后一篇文章会回看借用引用。