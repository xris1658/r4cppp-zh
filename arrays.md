[阅读英文原版](https://github.com/nrc/r4cppp/blob/master/arrays.md)

# 数组和动态数组

Rust 的数组和 C 的数组挺不一样的。对于初学者而言，数组有静态和动态两种。两种通常分别称作定长数组（fixed length array）和切片（slice）。我们会看到，第一种数组的名字不太好，因为两种数组都是定长的（和可扩张相对）。要可扩张“数组”的话，Rust 提供了 `Vec` 集合。

## 定长数组

定长数组的长度是静态获知的，是类型的一部分。例如 `[i32; 4]` 是长度为 4 的 `i32` 数组。

数组字面量和访问数组的语法和 C 类似：

```rs
let a: [i32, 4] = [1, 2, 3, 4]; // 和之前一样，类型标注可省略
println!("The second element is {}", a[1]);
```

（译者注：例子前的原文不是“和 C 类似”，而是“the same as C”。不过可以看到，Rust 中的数组字面量是方括号包围的，并非和 C 一模一样。）

各位会注意到，数据的下标运算和 C 一样，是从 0 开始的。

然而，和 C/C++<sup>[1](#1)</sup> 不同的是，数组下标运算会检查边界。其实所有访问数组的行为都会检查边界，换句话说，Rust 是一门更安全的语言。

如果尝试 `a[4]`，则会触发运行时崩溃（runtime panic，译者注：此处的 runtime panic 和之前的 runtime failure 应该不是一个东西，待补充二者区别）。遗憾的是，尽管（这个例子）明显有问题，Rust 编译器还没有聪明到报编译错误。（译者注：原文如此，如今这个例子会引发编译错误。）

如果你想活得危险些，或是需要从程序中榨干最后一滴性能，可以对数组做不带边界检查的下标运算。要这么做，对数组使用 `get_unchecked` 方法。不带边界检查的数组访问必须位于不安全代码块内。只有极其罕见的情况下需要这么干。

和 Rust 中其他的数据结构一样，数组默认不可变，可变性会继承。下标运算语法同样用于修改值：

```rs
let mut a = [1, 2, 3, 4];
1[3] = 5;
println!("{:?}", a);
```

和其他数据一样，可以通过获取引用的方式借用数组：

```rs
fn foo(a: &[i32, 4]) {
    println!("First: {}; last: {}", a[0], a[3]);
}

fn main() {
    foo(&[1, 2, 3,4]);
}
```

注意，下标运算对借用数组也有效。

##### 1

C++11 中有 `std::array<T, N>`，在使用 `at()` 成员函数时会进行边界检查（译者注：若越界则抛 `std::out_of_range` 异常，如果想进行静态的边界检查，可使用 `std::get`，详情参阅 C++17 的元组式访问）。