[阅读英文原版](https://github.com/nrc/r4cppp/blob/master/arrays.md)

# 数组和可扩张数组

Rust 的数组和 C 的数组挺不一样的。对于初学者而言，数组有静态和动态两种。两种通常分别称作定长数组（fixed length array）和切片（slice）。我们会看到，第一种数组的名字不太好，因为两种数组都是定长的（和可扩张相对）。要可扩张“数组”的话，Rust 提供了 `Vec` 集合。

## 定长数组

定长数组的长度是静态获知的，是类型的一部分。例如 `[i32; 4]` 是长度为 4 的 `i32` 数组。

数组字面量和访问数组的语法和 C 类似：

```rs
let a: [i32, 4] = [1, 2, 3, 4]; // 和之前一样，类型标注可省略
println!("The second element is {}", a[1]);
```

（译者注：例子前的原文不是“和 C 类似”，而是“the same as C”。不过可以看到，Rust 中的数组字面量是方括号包围的，并非和 C 一模一样。）

各位会注意到，数据的下标运算和 C 一样，是从 0 开始的。

然而，和 C/C++[^1] 不同的是，数组下标运算会检查边界。其实所有访问数组的行为都会检查边界，换句话说，Rust 是一门更安全的语言。

如果尝试 `a[4]`，则会触发运行时错误（runtime panic，译者注：此处的 runtime panic 和之前的 runtime failure 应该不是一个东西，待补充二者区别）。遗憾的是，尽管（这个例子）明显有问题，Rust 编译器还没有聪明到报编译错误。（译者注：原文如此，如今这个例子会引发编译错误。）

如果你想活得危险些，或是需要从程序中榨干最后一滴性能，可以对数组做不带边界检查的下标运算。要这么做，对数组使用 `get_unchecked` 方法。不带边界检查的数组访问必须位于不安全代码块内。只有极其罕见的情况下需要这么干。

和 Rust 中其他的数据结构一样，数组默认不可变，可变性会继承。下标运算语法同样用于修改值：

```rs
let mut a = [1, 2, 3, 4];
a[3] = 5;
println!("{:?}", a);
```

和其他数据一样，可以通过获取引用的方式借用数组：

```rs
fn foo(a: &[i32, 4]) {
    println!("First: {}; last: {}", a[0], a[3]);
}

fn main() {
    foo(&[1, 2, 3,4]);
}
```

注意，下标运算对借用数组也有效。

对 C++ 程序员而言，现在正适合说一说 Rust 数组最有趣的地方：数组的表示。Rust 的数组是值类型，和其他值一样在栈上分配，而数组对象是一系列值，而不是 C 中指向值的指针。因此上例中，`let a = [1_i32, 2, 3, 4];` 会在栈上分配 16 字节空间，`let b = a;` 会复制这 16 字节。如果要用 C 风格的数组，需要明确创建指向数组的指针，便可得到指向第一个元素的指针。

Rust 和 C++ 的数组的最后一个不同在于，Rust 数组可以实现特征，因此带有方法。例如，要查询数组长度，可以使用 `a.len()`。

## 切片

Rust 中的切片是编译时长度未知的数组。此类型的语法和定长数组类似，只是不写长度，例如 `[i32]` 是 32 位整数的切片，无法静态获取其长度。

切片有个特殊之处：由于编译器必须得知 Rust 中所有类型的大小，且不知道切片的长度，因此无法创建切片类型的值。例如，尝试写 `fn foo(x: [i32])`，则编译器报错。

因此，必须一直创建指向切片的指针（此规定有一些例外，可用于手写智能指针实现，不过现在可以忽略这些例外）。必须写成 `fn foo(x: &[i32])`（切片的借用引用）或 `fn foo(x: *mut [i32])`（指向切片的可变原始指针）等代码。

创建切片最简单的方法是通过转换（coercion）完成。Rust 中的隐式转换比 C++ 中的少得多。其中一种转换是将定长数组转换为切片。由于切片必须是指针值，因此这种转换实质上是指针间转换。例如，可以将 `&[i32; 4]` 转换为 `&[i32]`，例如：

```rs
let a: &[i32]= &[1, 2, 3, 4];
```

上例中，等号右侧是长度为 4 的定长数组，在栈上分配。接着取数组引用（类型为 `&[i32; 4]`。此引用被转换为 `&[i32]` 类型，并由 `let` 语句命名为 `a`。

同样，访问和 C 类似（使用 `[...]`），且使用边界检查。也可以使用 `len()` 检查长度。因此明显的是，某一处肯定是知道数组长度的。其实 Rust 中任意类型数组的长度都是已知的，因为这是边界检查的基本，而边界检查又是内存安全内在的一部分。切片的长度动态获知（和定长数组静态获知长度的行为相对），我们将切片类型称作动态大小类型（dynamically sized type，简称为 DST，还有别的动态大小类型，会在别处讲的）。

由于切片就是一系列值，切片大小不能作为切片的一部分存储，而是作为指针的一部分存储（记住，切片必须作为指针类型存在）。（和任意的指向 DST 的指针一样，）指向切片的指针是个胖指针（fat pointer），位宽为两个字（word），而非一个字，包含了指向类型的指针，以及一个负载（payload）。就切片而言，负载便是切片的长度。

上例中，指针 `a` 的位宽（在 64 位系统上）为 128。前 64 个字节存储序列 `[1, 2, 3, 4]` 中 `1` 的地址，后 64 个字节包含 `4`。对 Rust 程序员而言，胖指针通常可以当作普通指针用。不过还是了解一下好（比如说，这回影响使用转换可进行的操作）。

### 切片记号和范围

可以将切片理解为（借用的）数组视图。目前我们之前过数组所有内容的切片，但我们也可以创建数组部分内容的切片。这种行为拥有特别的记号，和下标运算的语法类似，但接受的是范围，而非单个整数。例如 `a[0..4]` 创建了 `a` 前四个元素的切片。注意，范围是左闭右开的。例如：

```rs
let a: [i32; 4] = [1, 2, 3, 4];
let b: &[i32] = &a; // 数组整体的切片
let c = &a[0..4]; // 也是数组整体的切片，类型也是 &[i32]
let c = &a[1..3]; // 中间两个元素的切片，类型是 &[i32]
let c = &a[1..]; // 最后三个元素的切片
let c = &a[..3]; // 前三个元素的切片
let c = &a[..]; // 又是数组整体的切片
let c = &b[1..3]; // 也可以创建切片的切片
```

注意上例的最后一行，即使是创建借用切片的切片，我们还是需要借用切片的结果（译者注：换言之，不能写成 `let c = b[1..3];`）。

范围语法不只可以用于切片语法。`a..b` 会创建从 `a` 到 `b-1` 的迭代器。这可以通过一般形式和其他迭代器结合，也可以用于 `for` 循环中：

```rs
// 打印从 1 到 10 的所有整数
for i in 1..11 {
    println!("{}", i);
}
```

（译者注：C++17 添加了 [`std::basic_string_view`](https://en.cppreference.com/w/cpp/string/basic_string_view)，C++20 添加了 [`std::span`](https://en.cppreference.com/w/cpp/container/span)，二者除了不拥有数据外，使用和工作方式与切片类似。不过 `std::span` 既可以静态指定长度，也可以动态指定长度。对于多维下标运算，C++23 添加了 [`std::mdspan`](https://en.cppreference.com/w/cpp/container/mdspan) 以及同时接收多维下标值的运算符重载 `[]`。）

## `Vec`

可扩张数组（vector）在堆上创建，是独占引用。因此（与 `Box<_>` 类似），它带有移动语义。我们可以将定长数组比作值，切片比作借用引用。类似可称，Rust 中的可扩张数组比作 `Box <_>` 指针。

和 `Box<_>` 类似，不要把 `Vec<_>` 想成值，想成智能指针。这么想会有用的。和切片类似，长度信息存储于“指针”中，此处的“指针”是 `Vec` 值。

`i32` 可扩张数组的类型为 `Vec<i32>`。没有可扩张数组字面量，不过使用宏 `vec!` 可以达到相同效果。也可以使用 `Vec::new()` 创建空的可扩张数组：

```rs
let v = vec![1, 2, 3, 4]; // 长度为 4 的 Vec<i32>
let v: Vec<i32> = Vec::new(); // 空的 i32 可扩张数组
```

上例的第二行中，类型标注必须写，使得编译器能知道可扩张数组的类型。如果要使用可扩张数组，类型标注或许可以不写。

与数组和切片一样，可以使用下标值的写法从可扩张数组中获取值（例如 `v[2]`）。同样，下标运算带边界检查。也可以用切片写法创建可扩张数组的切片（例如 `&v[1..3]`）。

可扩张数组还有一个特点，即长度可变：可以按需扩张与收缩。例如，`v.push(5)` 可以将元素 `5` 加入数组末尾（此操作要求 `v` 可变）。注意，扩张可能导致重分配，对于大数组而言意味着大量复制操作。要防止此现象，可以使用 `with_capacity` 为数组预分配空间，详情参阅 [Vec 文档](https://doc.rust-lang.org/std/vec/struct.Vec.html)。（译者注：C++ 内置的 `std::vector` 带有成员函数 `reserve`，用于指定容量大小。）

## `Index` 特征

提醒各位读者：本节很多内容都还没有好好地讲过。阅读教程时可以跳过这一节，因为这一节的内容无论如何都算高级主题了。

数组和可扩张数组的下标运算也用于其他的集合类型，例如 `HashMap`。也可以将其用于自己实现的集合类型。通过实现 `Index` 特征可以使类型用于下标运算（以及切片操作）。这是 Rust 为用户类型和内建类型（用与解引用智能指针的 `Deref`，以及 `Add` 和其他特征的工作方式都是类似的）提供良好语法的良好示例。

`Index` 特征形如

```rs
pub trait Index<Idx: ?Sized> {
    type Output: ?Sized;

    fn index(&self, index: Idx) -> &Self::Output;
}
```

`Idx` 是用于下标运算的类型。对多数下标运算的用法而言，此类型为 `usize`。对于切片而言，此类型是 `std::ops::Range` 的多个类型之一。`Output` 是由下标运算返回的类型，每种集合都不一样。对于切片而言，其类型为切片，而非单个元素的类型。`index` 是个方法，从集合中取出数据。注意，集合按引用传入，方法返回引用的生存期和集合的生存期是一致的。

要了解实现特征的方式，来看一下 `Vec` 的实现：

```rs
impl<T> Index<usize> for Vec<T> {
    type Output = T:

    fn index(&self, index: usize) -> &T {
        &(**self)[index]
    }
}
```

如上文所说，下标运算使用 `usize` 完成。对于 `Vec<T>`，下标运算返回一个 `T` 类型的元素，即 `Output` 的值。`index` 的实现有点奇怪：`(**self)` 将整个数组的视图作为切片获取，然后使用切片的下标运算获取元素，最终取元素的引用。

如果你自己实现了集合，可以通过类似方式实现 `Index`，为集合创建下标运算和切片操作的语法。

## 初始化器语法

和 Rust 中所有类型一样，数组和可扩张数组必须正确初始化。通常你只想用 0 填满整个数组，用数组字面量的语法会很难受。因此 Rust 提供了使用给定值填满整个数组的语法糖（syntactic sugar）：`[value; len]`。这样，要创建长度为 100 且填满 0 的数组，使用 `[0; 100]`。

对于可扩张数组类似的是，`vec![42; 100]` 可以返回一个 100 个元素，每个元素的值均为 42 的可扩张数组。

初始值不只可以是整数，可以是任何表达式。对于数组的初始化器而言，长度必须是整数常量表达式。对于 `vec!` 而言，任何类型为 `usize` 的表达式都行。

[^1]: C++11 中有 `std::array<T, N>`，在使用 `at()` 成员函数时会进行边界检查（译者注：若越界则抛 `std::out_of_range` 异常，如果想进行静态的边界检查，可使用 `std::get`，详情参阅 C++17 的元组式访问）。