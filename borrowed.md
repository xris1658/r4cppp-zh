[阅读英文原版](https://github.com/nrc/r4cppp/blob/master/borrowed.md)

# 借用指针

上篇文章中，我介绍了独占指针。这次我来介绍另一种在多数 Rust 程序中常见得多的指针：借用指针（又名借用引用，简称引用）。

要获取一个已有值的引用（与独占指针在堆上建值并指向值的行为相对），我们必须使用 `&`，即借用引用。借用引用大概是 Rust 中最常见的指针类型，如果要替代 C++ 中的指针或引用（例如，用于函数的按引用传参），大概率就用借用引用。

使用 `&` 运算符创建借用引用并指示引用类型，使用 `*` 解引用。独占指针的自动解引用同样适用。例如：

```rs
fn foo() {
    let x = &3; // 类型：&i32
    let y = *x; // 3，类型：i32
    bar(x, *x);
    bar(&y, y);
}

fn bar(z: &i32, i: i32) {
    // ...
}
```

`&` 运算符不会分配内存（只能创建已有值的借用引用），借用引用离开作用域不会回收内存。

借用引用不是独占的，可以创建多个指涉同一个值的引用。例如：

```rs
fn foo() {
    let x = 5; // 类型：i32
    let y = &x; // 类型：&i32
    let z = y; // 类型：&i32
    let w = y; // 类型：&i32
    println!("These should all be 5: {} {} {}", *w, *y, *z);
}
```

和值一样，借用引用默认是不可变的。可以使用 `&mut` 创建可变引用，或表示可变引用类型。可变借用引用是独占的（一个值只能有一个可变借用引用，且只能在没有不可变借用引用时创建可变借用引用）。可以在需要用不可变引用时使用可变引用替代，但反过来不行。用下例总结上述内容：

```rs
fn bar(x: &i32) { ... }
fn bar_mut(x: &mut i32) { ... } // &mut i32 是指涉 i32 的可变引用

fn foo() {
    let x = 5;
    // let xr = &mut x;         // 错误：不能创建指涉不可变变量的可变引用
    let xr = &x;                // 正确（创建不可变引用）
    bar(xr);
    // bar_mut(xr);             // 错误：接受不可变引用

    let mut x = 5;
    let xr = &x;                // 正确（创建不可变引用）
    // *xr = 4;                 // 错误：修改不可变引用
    // let xr = &mut x;         // 错误：已有不可变引用，因此无法创建可变引用

    let mut x = 5;
    let xr = &mut x;            // 正确（创建可变引用）
    *xr = 4;                    // 正确
    // let xr2 = &x;            // 错误：已有可变引用，因此无法创建不可变引用
    // let xr2 = &mut x;        // 错误：一次只能有一个可变引用
    bar(xr);                    // 正确
    bar_mut(xr);                // 正确
}
```

（译者注：和 C++ 不同的是，Rust 可以创建“临时”值的可变借用引用：`let x = &mut 3; *x = 4;`）

注意，引用是否可变和占有引用的变量的可变性无关。这一点与 C++ 指针是否可变和指向的值是否可变是类似的。这一点和独占指针相反，独占指针中，指针是否可变和内容是否可变是一致的。例如：

```rs
fn foo() {
    let mut x = 5;
    let mut y = 6;
    let xr = &mut x;
    // xr = &mut y;      // 错误：xr 不可变

    let mut x = 5;
    let mut y = 6;
    let mut xr = &mut x;
    xr = &mut y;         // 正确

    let x = 5;
    let y = 6;
    let mut xr = &x;
    xr = &y;             // 正确：尽管引用的数据不可变，但 xr 是可变的
}
```

如果借用了可变值，则借出的时间段内，值是不可变的。一旦借用指针离开作用域，值就又可以修改了。这一点和独占指针相反，独占指针被移走就不能再用了。例如：

```rs
fn foo() {
    let mut x = 5;         // 类型：i32
    {
        let y = &x;        // 类型：&i32
        // x = 4;          // 错误：x 被借出
        println!("{} {}", y, x); // 正确：x 可读
    }
    x = 4;                 // 正确：y 已不存在
}
```

获得值的可变引用时也一样：借出时值还是不可变。总的来说，Rust 中的数据只能通过一个变量或一个指针修改。此外，由于拥有了可变引用，无法创建不可变引用。这一点限制了使用底层值的方式：

```rust
fn foo() {
    let mut x = 5;            // 类型：i32
    {
        let y = &mut x;       // 类型：&mut i32
        //x = 4;              // 错误：x 被借出
        //println!("{}", x);  // 错误：需要借回 x
    }
    x = 4;                    // 正确：y 已不存在
}
```

和 C++ 不同，Rust 不会自动引用值。因此，如果有个函数按引用接收参数，则调用方必须自行引用参数。然而，指针类型会自动转换为引用：
```rs
fn foo(x: &i32) { ... }

fn bar(x: i32, y: Box<i32>) {
    foo(&x);
    // foo(x); // 错误：接受 &i32，找到 i32
    foo(y);    // 正确
    foo(&*y);  // 也正确，写法更明显，但代码风格不好
}
```

## 比较 `mut` 和 `const`

讲到这里，或许值得比较一下 Rust 中的 `mut` 和 C++ 中的 `const`。大体来看，二者是相反的。Rust 中的值默认不可变，可使用 `mut` 设为可变。C++ 中的值默认可变，可使用 `const` 设为不可变。更精妙且更重要的差别在于，C++ 的常量性只用于当前使用值的场合（译者注：可以简单理解为作用域），而 Rust 的不可变性用于所有使用值的场合。因此，在 C++ 中，我有个 `const` 值，某段代码可能有此值的非 `const` 引用，而我不知道值会被修改。在 Rust 中，有了不可变的值，就保证不可变。（译者注：Rust 这种“一个值只能同时包含若干个不可变引用，或者只包含一个可变引用”的规则一部分是出于多线程环境的考量。若有多个线程同时访问值，且至少有一个线程在写值，便会出现数据竞争。Rust 将引用数量的规则包含于语言本身，防止数据竞争，从而保证了线程安全性。）

之前提到过，所有的可变变量都是独占的。如果有个可变值，可以确保值不会被修改，除非自己修改。进一步说，由于确保没有其他代码依靠此值不变的情况，我们想改值就能改。

## 借用行为和生存期

Rust 的一个首要的安全目标就是防止悬垂指针（指针比指向的内存活得久）。Rust 中不可能出现悬垂的借用引用。只有创建的引用比内存活得短才有效（最多也只是二者生存期一致）。换言之，引用的生存期必须比引用的值的生存期短。

本文中所有例子都满足这一点。由 `{}` 或函数引入的作用域和生存期绑定：当变量离开作用域时，其生存期结束。若尝试创建的引用比值的生存期更短，例如作用域更小，则编译器报错。例如：

```rs
fn foo() {
    let x = 5;
    let mut xr = &x; // 正确：x 和 xr 的生存期一致
    {
        let y = 6;
        xr = &y // 错误：xr 比 y 活得久
    } // y 在此处析构
    println!("{:?}", xr); // xr 在此处使用，因此比 y 活得久。尝试注释这一行
} // x 和 xr 在此处析构
```

上例中，`xr` 和 `y` 生存期不一致，因为 `y` 创建得比 `xr` 晚。不过有趣之处在于生存期结束，因为无论如何都不能在值创建前就引用这个值，同样，Rust 会保证这一点，使其比 C++ 更安全。

## 显式生存期

倒腾了一阵子借用指针后，各位大概会遇到具有显式生存期的借用指针。其语法形如 `&'a T`（与 `&T` 比较一下）。这一主题内容多一些，因为同时需要涵盖生存期多态的内容，因此之后另开一文去讲（不过还要先讲几个少用的指针类型）。目前，我只想说，`&T` 是 `&'a T` 的缩写，其中 `a` 是当前作用域，即声明类型的作用域。